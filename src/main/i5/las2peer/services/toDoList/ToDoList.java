package i5.las2peer.services.toDoList;

import java.net.HttpURLConnection;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.Consumes;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.sun.javafx.collections.MappingChange.Map;

import i5.las2peer.api.Service;
import i5.las2peer.restMapper.RESTService;
import i5.las2peer.restMapper.annotations.ServicePath;
import i5.las2peer.services.toDoList.database.DatabaseManager;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import io.swagger.annotations.Contact;
import io.swagger.annotations.Info;
import io.swagger.annotations.License;
import io.swagger.annotations.SwaggerDefinition;
import io.swagger.jaxrs.Reader;
import io.swagger.models.Swagger;
import io.swagger.util.Json;

import org.glassfish.jersey.server.model.Resource;
//import org.apache.commons.lang3.ArrayUtils;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;


/**
 * 
 * ToDoList Microservice Sample
 * 
 * This microservice was generated by the CAE (Community Application Editor). If you edit it, please
 * make sure to keep the general structure of the file and only add the body of the methods provided
 * in this main file. Private methods are also allowed, but any "deeper" functionality should be
 * outsourced to (imported) classes.
 * 
 */
@ServicePath("ToDoList")
@SwaggerDefinition(
    info = @Info(title = "ToDoList Microservice Sample", version = "0.1",
        description = "A LAS2peer microservice generated by the CAE.",
        termsOfService = "none",
        contact = @Contact(name = "desared", email = "CAEAddress@gmail.com") ,
        license = @License(name = "BSD",
            url = "https://github.com/CAE-Community-Application-Editor/microservice-ToDoList-Microservice-Sample/blob/master/LICENSE.txt") ) )
public class ToDoList extends RESTService {

	@Override
	protected void initResources() {
		getResourceConfig().register(Resource.class);
	}
	
	
  /*
   * Database configuration
   */
  private String jdbcDriverClassName;
  private String jdbcLogin;
  private String jdbcPass;
  private String jdbcUrl;
  private String jdbcSchema;
  private static DatabaseManager dbm;


  public ToDoList() {
    // read and set properties values
    setFieldValues();
    // instantiate a database manager to handle database connection pooling and credentials
    dbm = new DatabaseManager(jdbcDriverClassName, jdbcLogin, jdbcPass, jdbcUrl, jdbcSchema);
  }

  // //////////////////////////////////////////////////////////////////////////////////////
  // Service methods.
  // //////////////////////////////////////////////////////////////////////////////////////

  
  @Path("/")
  public static class Resource {
	  /**
	   * 
	   * postList
	   * 
	   * @param listContent a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  @POST
	  @Path("/")
	  @Produces(MediaType.TEXT_PLAIN)
	  @Consumes(MediaType.TEXT_PLAIN)
	  @ApiResponses(value = {
	       @ApiResponse(code = HttpURLConnection.HTTP_CREATED, message = "ListSent"),
	       @ApiResponse(code = HttpURLConnection.HTTP_INTERNAL_ERROR, message = "internalError")
	  })
	  @ApiOperation(value = "postList", notes = "")
	  public Response postList(String listContent) {
		  {		
			
			  String insertQuery = "";
			 		    Connection conn = null;
			    PreparedStatement stmnt = null;
			    // split the message by semicolon since data belongs to two different 
			    // create two strings: caption and message
			    String[] str_array = listContent.split(";");
				  String caption = str_array[0]; 
				  String message = str_array[1];
			    		    try {
			      conn = dbm.getConnection();
			      // formulate query statement for message input
			      insertQuery = "INSERT INTO list (ListContent,MessageContent)" + "VALUES ('" + caption + "' , '" + message + "')";
			      stmnt = conn.prepareStatement(insertQuery);
			      // execute query 
			      stmnt.executeUpdate();
			      // message displayed for successful response
			      String listCreated = "Data Sent!";
			      return Response.status(201).entity(listCreated).build();
			    } catch (Exception e) {
			      e.printStackTrace();
			      // InternalError
			      String error = "Problems: " + e.getMessage();      
			      return Response.serverError().entity(error).build();
			    } finally {
			      // free resources
			      try {
			        stmnt.close();
			        conn.close();
			      } catch (Exception e) {
			        e.printStackTrace();
			        // InternalError
			        // message displayed in case of errors
			        String error = "Problems: " + e.getMessage();
			        return Response.serverError().entity(error).build();
			      }
			    }
			  }

		  
	  }
	  
	 
	  /**
	   * 
	   * getData
	   * 
	   * @param DataContent a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  @GET
	  @Path("/")
	  @Produces(MediaType.TEXT_PLAIN)
	  @Consumes(MediaType.TEXT_PLAIN)
	  @ApiResponses(value = {
			  @ApiResponse(code = HttpURLConnection.HTTP_OK, message = "listRetrieved"),
		       @ApiResponse(code = HttpURLConnection.HTTP_INTERNAL_ERROR, message = "internalError")
	  })
	  @ApiOperation(value = "getData", notes = "")
	  public Response getData(String DataContent) {
		  {
			   String getQuery = "";
			    Connection conn = null;
			    PreparedStatement stmnt = null;
			    try {
			    	
			      conn = dbm.getConnection();
			      // formulate query statement for retrieving data from table list in backend
			      getQuery = "SELECT id, ListContent, MessageContent From list ; "; 
			      stmnt = conn.prepareStatement(getQuery);
			      // execute query
			      ResultSet rs = stmnt.executeQuery();
			      // after retrieving all the data, it should be cleaned
			      // seperate all data according to id
			      // structure all the data properly according to caption and message
			      rs.last();
			      int numrows = rs.getRow(); 
			      rs.beforeFirst();
			      int[] id = new int[numrows];
			      String[] ListContent = new String[numrows];
			      String[] MessageContent = new String[numrows];
			    	int i = 0; 
			 		   		     while(rs.next()){	
			 		   		    	id[i] = rs.getInt("id");
			    	    ListContent[i] = rs.getString("ListContent");
			    	    MessageContent[i] = rs.getString("MessageContent");
			    	     	    i++;
			   		     } 		  	
			 		 
			     rs.close();
			    String ID =  	Arrays.toString(id);
			     String AllData =  	Arrays.toString(ListContent);
			     String Message =  	Arrays.toString(MessageContent);
			     ID = ID.substring(1, ID.length() - 1);
			     AllData = AllData.substring(1, AllData.length() - 1);
			     Message = Message.substring(1, Message.length() - 1);
	             // create a string where all the data is stored
			     // comma-seperated string to seperate data for further purposes
			     String allTogether = ID + "," + AllData + "," + Message ;
			     return Response.ok(allTogether).build();
			      
			    } catch (Exception e) {
			      e.printStackTrace();
			      // InternalError
			      // output error message
			      String error = "Problems: " + e.getMessage();
			      return Response.serverError().entity(error).build();
			    } 
			  }

		  
	  }
	 
	  /**
	   * 
	   * updateData
	   * 
	   * @param UpdateContent a String
	   * 
	   * @param id a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  
	  @PUT
	  @Path("/{id}")
	  @Produces(MediaType.TEXT_PLAIN)
	  @Consumes(MediaType.TEXT_PLAIN)
	  @ApiResponses(value = {
			  @ApiResponse(code = HttpURLConnection.HTTP_OK, message = "listUpdated"),
		       @ApiResponse(code = HttpURLConnection.HTTP_INTERNAL_ERROR, message = "internalError")
	  })
	  @ApiOperation(value = "updateData", notes = "")
	  public Response updateData(@PathParam("id") String id, String UpdateContent ) {
		  {   
			  
			  // seperate the available data in different categories by semicolon-seperated 
			  String[] str_array = UpdateContent.split(";");
			  String inputMsg = str_array[0]; 
			  String message = str_array[1]; 
			  String DeleteID = str_array[2];
			  // create connection
			    Connection conn = null;
			    PreparedStatement stmnt = null;
			    PreparedStatement stmnt1 = null;

			    try {
			      conn = dbm.getConnection();
			      			  
					   String getQuery = "";
					   String Query = "";

				 // formulate query statement for updating caption and message based on id
			      getQuery = "Update list set ListContent = '" + inputMsg + "' where id = '"+ DeleteID + "';";
			      Query = "Update list set MessageContent = '" + message + "' where id = '"+ DeleteID + "';";
	              // execute query
			      stmnt = conn.prepareStatement(getQuery);
			       stmnt.executeUpdate();		   		   
			       stmnt1 = conn.prepareStatement(Query);
			       stmnt1.executeUpdate();	 
			       // output message in case of successful update
			      String updateList = "Message Updated!";
			      return Response.ok(updateList).build();
			      
			    } catch (Exception e) {
			      e.printStackTrace();
			      // InternalError
			      // output message in case of errors
			      String error = "Problems: " + e.getMessage();
			      return Response.serverError().entity(error).build();
			    } 
			  }

		  
	  }
	  /**
	   * 
	   * deleteList
	   * 
	   * @param DeleteContent a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  
	  @DELETE
	  @Path("/")
	  @Produces(MediaType.TEXT_PLAIN)
	  @Consumes(MediaType.TEXT_PLAIN)
	  @ApiResponses(value = {
	       @ApiResponse(code = HttpURLConnection.HTTP_NOT_FOUND, message = "ListNotFound"),
	       @ApiResponse(code = HttpURLConnection.HTTP_OK, message = "ListDeleted"),
	       @ApiResponse(code = HttpURLConnection.HTTP_BAD_REQUEST, message = "BadList")
	  })
	  @ApiOperation(value = "deleteList", notes = "")
	  public Response deleteList(String DeleteContent) 
		  {
			   String deleteQuery = "";
				  // create connection
			    Connection conn = null;
			    PreparedStatement stmnt = null;
			    try {
					  // create connection
			      conn = dbm.getConnection();
					 // formulate query statement for deleting caption and messages based on id
			      deleteQuery = "Delete From list Where id = '"+ DeleteContent + "';";
			      stmnt = conn.prepareStatement(deleteQuery);
			      // execute query
			      stmnt.executeUpdate();		      
			      // Message output in case of successful deletion 
			      String listRemoved = "Data Deleted!";
			      return Response.ok(listRemoved).build();
			    } catch (Exception e) {
			      e.printStackTrace();
			      // InternalError
			      // output message in case of errors
			      String listNotFound = "Problems: " + e.getMessage();
			      return Response.status(404).entity(listNotFound).build();
			    }
			    finally {
				      // free resources
				      try {
				        stmnt.close();
				        conn.close();
				      } catch (Exception e) {
				        e.printStackTrace();
				        // InternalError
				        String listNotFound = "Problems: " + e.getMessage();
				        return Response.serverError().entity(listNotFound).build();
				      }
				    }
		  }
	  
	 


	  // //////////////////////////////////////////////////////////////////////////////////////
	  // Methods required by the LAS2peer framework.
	  // //////////////////////////////////////////////////////////////////////////////////////



	  /**
	   * 
	   * Returns the API documentation of all annotated resources for purposes of Swagger documentation.
	   * 
	   * @return The resource's documentation
	   * 
	   */
	  @GET
	  @Path("/swagger.json")
	  @Produces(MediaType.APPLICATION_JSON)
	  public Response getSwaggerJSON() {
	    Swagger swagger = new Reader(new Swagger()).read(this.getClass());
	    if (swagger == null) {
	      return Response.status(404).entity("Swagger API declaration not available!").build();
	    }
	    try {
	      return Response.ok(Json.mapper().writeValueAsString(swagger)).build();
	    } catch (JsonProcessingException e) {
	      e.printStackTrace();
	      return Response.serverError().entity(e.getMessage()).build();
	    }
	  }
  }
}
