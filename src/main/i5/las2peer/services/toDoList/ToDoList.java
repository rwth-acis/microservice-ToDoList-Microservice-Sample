package i5.las2peer.services.toDoList;

import java.net.HttpURLConnection;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.ws.rs.DELETE;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.Consumes;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.jsonschema.JsonSchema;
import com.sun.javafx.collections.MappingChange.Map;

import i5.las2peer.api.Service;
import i5.las2peer.restMapper.RESTService;
import i5.las2peer.restMapper.annotations.ServicePath;
import i5.las2peer.services.toDoList.database.DatabaseManager;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import io.swagger.annotations.Contact;
import io.swagger.annotations.Info;
import io.swagger.annotations.License;
import io.swagger.annotations.SwaggerDefinition;
import io.swagger.jaxrs.Reader;
import io.swagger.models.Swagger;
import io.swagger.util.Json;

import org.glassfish.jersey.server.model.Resource;
import org.json.simple.JSONArray;
//import org.apache.commons.lang3.ArrayUtils;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.json.simple.parser.JSONParser;


/**
 * 
 * ToDoList Microservice Sample
 * 
 * This microservice was generated by the CAE (Community Application Editor). If you edit it, please
 * make sure to keep the general structure of the file and only add the body of the methods provided
 * in this main file. Private methods are also allowed, but any "deeper" functionality should be
 * outsourced to (imported) classes.
 * 
 */
@ServicePath("ToDoList")
@SwaggerDefinition(
    info = @Info(title = "ToDoList Microservice Sample", version = "0.1",
        description = "A LAS2peer microservice generated by the CAE.",
        termsOfService = "none",
        contact = @Contact(name = "desared", email = "CAEAddress@gmail.com") ,
        license = @License(name = "BSD",
            url = "https://github.com/CAE-Community-Application-Editor/microservice-ToDoList-Microservice-Sample/blob/master/LICENSE.txt") ) )
public class ToDoList extends RESTService {

	@Override
	protected void initResources() {
		getResourceConfig().register(Resource.class);
	}
	
	
  /*
   * Database configuration
   */
  private String jdbcDriverClassName;
  private String jdbcLogin;
  private String jdbcPass;
  private String jdbcUrl;
  private String jdbcSchema;
  private static DatabaseManager dbm;


  public ToDoList() {
    // read and set properties values
    setFieldValues();
    // instantiate a database manager to handle database connection pooling and credentials
    dbm = new DatabaseManager(jdbcDriverClassName, jdbcLogin, jdbcPass, jdbcUrl, jdbcSchema);
  }

  // //////////////////////////////////////////////////////////////////////////////////////
  // Service methods.
  // //////////////////////////////////////////////////////////////////////////////////////

  
  @Path("/")
  public static class Resource {
	  /**
	   * 
	   * postList
	   * 
	   * @param listContent a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  @POST
	  @Path("/")
	  @Produces(MediaType.TEXT_PLAIN)
	  @Consumes(MediaType.APPLICATION_JSON)
	  @ApiResponses(value = {
	       @ApiResponse(code = HttpURLConnection.HTTP_CREATED, message = "ListSent"),
	       @ApiResponse(code = HttpURLConnection.HTTP_INTERNAL_ERROR, message = "internalError")
	  })
	  @ApiOperation(value = "postList", notes = "")
	  public Response postList(String contentString) {
		  JSONParser parser = new JSONParser();
		  JSONObject content;  
		  Connection conn = null;
		  PreparedStatement stmnt = null;
		  
		  try {
			  content = (JSONObject) parser.parse(contentString);
			  conn = dbm.getConnection();
			  // formulate query statement for message input
			  String insertQuery = "INSERT INTO list (ListContent,MessageContent)" + "VALUES (?,?);";
			  stmnt = conn.prepareStatement(insertQuery);
			  stmnt.setString(1, (String) content.get("caption"));
			  stmnt.setString(2, (String) content.get("message"));
			  // execute query 
			  stmnt.executeUpdate();
			  // message displayed for successful response
			  return Response.status(201).build();
	    } catch (Exception e) {
	      e.printStackTrace();
	      // InternalError
	      String error = "Problems: " + e.getMessage();      
	      return Response.serverError().entity(error).build();
	    } finally {
	      // free resources
	      try {
	        stmnt.close();
	        conn.close();
	      } catch (Exception e) {
	        e.printStackTrace();
	        // InternalError
	        // message displayed in case of errors
	        String error = "Problems: " + e.getMessage();
	        return Response.serverError().entity(error).build();
	      }
	    }	  
}
	  
	 
	  /**
	   * 
	   * getData
	   * 
	   * @param DataContent a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  @SuppressWarnings("unchecked")
	@GET
	  @Path("/")
	  @Produces(MediaType.APPLICATION_JSON)
	  @ApiResponses(value = {
			  @ApiResponse(code = HttpURLConnection.HTTP_OK, message = "listRetrieved"),
		       @ApiResponse(code = HttpURLConnection.HTTP_INTERNAL_ERROR, message = "internalError")
	  })
	  @ApiOperation(value = "getData", notes = "")
	  public Response getData(String DataContent) {
		  {
			   String getQuery = "";
			    Connection conn = null;
			    PreparedStatement stmnt = null;
			    try {
			    	
			      conn = dbm.getConnection();
			      // formulate query statement for retrieving data from table list in backend
			      getQuery = "SELECT id, ListContent, MessageContent From list ; "; 
			      stmnt = conn.prepareStatement(getQuery);
			      // execute query
			      ResultSet rs = stmnt.executeQuery();
			      
			      
			      JSONArray result = new JSONArray();
			      
			      while(rs.next()) {
			    	  JSONObject obj = new JSONObject();
			    	  obj.put("id", rs.getInt(1));
			    	  obj.put("caption", rs.getString(2));
			    	  obj.put("message", rs.getString(3));
			    	  result.add(obj);
			      }
			      
			      return Response.ok(result.toJSONString()).build();
			      
			    } catch (Exception e) {
			      e.printStackTrace();
			      // InternalError
			      // output error message
			      String error = "Problems: " + e.getMessage();
			      return Response.serverError().entity(error).build();
			    } 
			  }

		  
	  }
	 
	  /**
	   * 
	   * updateData
	   * 
	   * @param UpdateContent a String
	   * 
	   * @param id a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  
	  @PUT
	  @Path("/{id}")
	  @Consumes(MediaType.APPLICATION_JSON)
	  @ApiResponses(value = {
			  @ApiResponse(code = HttpURLConnection.HTTP_OK, message = "listUpdated"),
		      @ApiResponse(code = HttpURLConnection.HTTP_INTERNAL_ERROR, message = "internalError")
	  })
	  @ApiOperation(value = "updateData", notes = "")
	  public Response updateData(@PathParam("id") int id, String updateContent) {
		  
		  
		    JSONParser parser = new JSONParser();
		    JSONObject content;
		    try {
		    	content = (JSONObject) parser.parse(updateContent);
	  
		    	// create connection
		    	Connection conn = null;
		    	PreparedStatement stmnt = null;
	
		    
		    	conn = dbm.getConnection();
		    	
		    	//Check existence
		    	stmnt = conn.prepareStatement("SELECT COUNT(*) from list WHERE id = ?");
		    	stmnt.setInt(1, id);
		    	ResultSet exists = stmnt.executeQuery();
		    	exists.first();
		    	if(exists.getInt(1) == 0){
		    		return Response.status(404).build();
		    	}
	  			  
		    	// formulate query statement for updating caption and message based on id
		    	String captionQuery = "Update list set ListContent = ? where id = ?;";
		    	String messageQuery = "Update list set MessageContent = ? where id = ?;";
	  
		    	// execute query1
		    	stmnt = conn.prepareStatement(captionQuery);
		    	stmnt.setString(1, (String) content.get("caption"));
		    	stmnt.setInt(2, id);
		    	stmnt.executeUpdate();
	  
		    	//execute query2
		    	stmnt = conn.prepareStatement(messageQuery);
		    	stmnt.setString(1, (String) content.get("message"));
		    	stmnt.setInt(2, id);
		    	stmnt.executeUpdate();
		    	// output message in case of successful update
		    	return Response.ok().build();
		    } catch (Exception e) {
		    	e.printStackTrace();
		    	// InternalError
		    	// output message in case of errors
		    	String error = "Problems: " + e.getMessage();
		    	return Response.serverError().entity(error).build();
		    }   
	  }
	  /**
	   * 
	   * deleteList
	   * 
	   * @param DeleteContent a String
	   * 
	   * @return HttpResponse
	   * 
	   */
	  
	  @DELETE
	  @Path("/{id}")
	  @ApiResponses(value = {
	       @ApiResponse(code = HttpURLConnection.HTTP_NOT_FOUND, message = "ListNotFound"),
	       @ApiResponse(code = HttpURLConnection.HTTP_OK, message = "ListDeleted"),
	       @ApiResponse(code = HttpURLConnection.HTTP_BAD_REQUEST, message = "BadList")
	  })
	  @ApiOperation(value = "deleteList", notes = "")
	  public Response deleteList(@PathParam("id") int id) 
		  {
			    Connection conn = null;
			    PreparedStatement stmnt = null;
			    try {
			    	// create connection
			    	conn = dbm.getConnection();
			    	
			    	
			    	//Check existence
			    	stmnt = conn.prepareStatement("SELECT COUNT(*) from list WHERE id = ?");
			    	stmnt.setInt(1, id);
			    	ResultSet exists = stmnt.executeQuery();
			    	exists.first();
			    	if(exists.getInt(1) == 0){
			    		return Response.status(404).build();
			    	}
			    	
			    	// formulate query statement for deleting caption and messages based on id
			    	String deleteQuery = "Delete From list Where id = ?;";
			      stmnt = conn.prepareStatement(deleteQuery);
			      stmnt.setInt(1, id);
			      // execute query
			      stmnt.executeUpdate();		      
			      return Response.ok().build();
			    } catch (Exception e) {
			      e.printStackTrace();
			      // InternalError
			      // output message in case of errors
			      String listNotFound = "Problems: " + e.getMessage();
			      return Response.status(404).entity(listNotFound).build();
			    }
			    finally {
				      // free resources
				      try {
				        stmnt.close();
				        conn.close();
				      } catch (Exception e) {
				        e.printStackTrace();
				        // InternalError
				        String listNotFound = "Problems: " + e.getMessage();
				        return Response.serverError().entity(listNotFound).build();
				      }
				    }
		  }
	  
	 


	  // //////////////////////////////////////////////////////////////////////////////////////
	  // Methods required by the LAS2peer framework.
	  // //////////////////////////////////////////////////////////////////////////////////////



	  /**
	   * 
	   * Returns the API documentation of all annotated resources for purposes of Swagger documentation.
	   * 
	   * @return The resource's documentation
	   * 
	   */
	  @GET
	  @Path("/swagger.json")
	  @Produces(MediaType.APPLICATION_JSON)
	  public Response getSwaggerJSON() {
	    Swagger swagger = new Reader(new Swagger()).read(this.getClass());
	    if (swagger == null) {
	      return Response.status(404).entity("Swagger API declaration not available!").build();
	    }
	    try {
	      return Response.ok(Json.mapper().writeValueAsString(swagger)).build();
	    } catch (JsonProcessingException e) {
	      e.printStackTrace();
	      return Response.serverError().entity(e.getMessage()).build();
	    }
	  }
  }
}
